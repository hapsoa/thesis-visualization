어제 하고 싶었던 설계는

그냥 노드들을 모두 같은 방식으로 뿌린다는 것이다.

sibling weight 없이 말이다.

없게 되면, 노드를 뿌리는데 있어서 일정간격을 유지하는 방식으로 하는데

해당 클러스터의 노드수만큼 각도를 차지하고, 그 해당각도에 노드를 균등하게 배치한다.
대신 각 노드를 클릭했을 때 잘 보여줘야 하므로, 부모와 자식을 연결하는 선을 색으로 구분하고

클러스터에 포함되지 않는 노드들과 연관이 있을 수 있는데,

그 녀석들을 모두 라드비즈 변수에 몰아서 넣어두느냐, 배제하느냐,,

배제한다면 왜곡이 발생한다. 배제시 
넣어도 왜곡이 발생한다. 

라드비즈가 어차피 왜곡되는듯 한데, 기타 변수들을 여기저기에 넣거나 몰아넣는다. 각도를 차지하는 비율이 매우 작을 것이다. 대신 회색노드들로 처리한다.

그리고 부모와 자식을 연결해주는 선을 그린다.

한 연도의 노드들이 너무 많아 겹치는게 많더라도,
그 해당 클러스터의 각도가 커지게 되면, 각도에 대한 왜곡또한 발생한다고 볼 수 있으므로

집약시킨다.

이것은 어쩔수 없고, 만약 겹치는 곳이 있다면 호버시 확대해서 현미경 처리를 한다.

노드끼리 겹친 경우 호버시 해당 부분을 잡아서

3배 수준으로 확대시킨다.
부모(노랑) 자식(연두) 뎁스가 깊어질수록 선의 색이 연해진다.
굵기도 존재할수 있겠네,


해당 클러스터의 해당연도의 노드들을 수집할 수 있다면, 

a.해당 연도의 원의 둘레, b.cluster의 theta, c.노드의 radius, d.해당 연도의 노드의 클러스터의 노드 수

해당 연도의 원둘레 * (2*PI / cluster의 theta / 해당 연도의 노드의 클러스터의 노드 수) < 노드의 radius



노드 뿌릴 공간이 좁아서, 노드를 집약해서 뿌리면, flocking 알고리즘으로 벌린다.

벌린 노드끼리 그려준다. 하지만 노드 수가 최대 몇개를 지정해줘야 한다.

더 작은 녀석들은 그려줄 수 없거나, 그 이상일 때는 집약시키도록 한다.

데이터 플로우 차트 : 데이터베이스(mongoDB) -> 서버 -> 노드를 뿌린다.



서로 연결되어 있을 때, 최대한 가까이 있어야 한다. 가까이 있다는 것은 각도가 같다는 뜻이다.

그렇게 하면, 서로 같은 각도에 위치 시킬 수 있다.



아래가 기준 선이라면 위로 가운데 중점으로 타고 올라간다.
그리고 다시 아래로 중점을 맞춰가면서 내려간다.
(같은 자식 노드를 가지고 있는 경쟁 노드가 없으면, 배치시키지 않는다.)
경쟁 노드가 누구인지를 알아 낸다.
같은 클러스터 내에서만, 실현할 수 있다.

외부 클러스터에 대해서는, 
